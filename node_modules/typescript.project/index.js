var api = require('typescript.api');
var async = require('async');
var fs = require('fs');

function sort(modules) {
    var queue = [];

    var result = [];

    var max_iterations = modules.length * modules.length;

    var iteration = 0;

    for (var n in modules) {
        queue.push(modules[n]);
    }

    while (queue.length > 0) {
        var item = queue.shift();

        var resolved = true;

        var references = item.references;

        for (var n in references) {
            var _module = null;

            for (var m in result) {
                if (result[m].name == references[n]) {
                    _module = result[m];

                    break;
                }
            }

            if (_module == null) {
                resolved = false;

                break;
            }
        }

        if (resolved) {
            result.push(item);
        } else {
            queue.push(item);
        }

        iteration = iteration + 1;

        if (iteration > max_iterations) {
            throw new Error("Unknown module reference or Cyclic Reference.");

            return modules;
        }
    }

    return result;
}
exports.sort = sort;

function show_errors(units) {
    for (var n in units) {
        for (var m in units[n].diagnostics) {
            console.log(units[n].diagnostics[m].toString());
        }
    }
}
exports.show_errors = show_errors;

function write_source(module, basepath, compiled) {
    var source = basepath + "/node_modules/" + module.name + "/index.js";

    var writestream = fs.createWriteStream(source);

    for (var n in compiled) {
        var unit = compiled[n];

        writestream.write(unit.content);
    }

    writestream.write("module.exports = exports;");

    writestream.end();
}
exports.write_source = write_source;

function write_declaration(module, basepath, compiled) {
    var source = basepath + "/node_modules/" + module.name + "/decl/" + module.name + ".d.ts";

    var writestream = fs.createWriteStream(source);

    for (var n in compiled) {
        var unit = compiled[n];

        var pattern = /\/\/\/ <reference path="(.*?)" \/>/g;

        var content = unit.declaration.replace(pattern, '');

        writestream.write(content);
    }

    writestream.end();
}
exports.write_declaration = write_declaration;

function copy_dependancies(module, basepath) {
    var declfile = basepath + "/node_modules/" + module.name + "/index.ts";

    for (var n in module.references) {
        console.log('   copying declaration ' + module.references[n]);

        var source = basepath + "/node_modules/" + module.references[n] + "/decl/" + module.references[n] + ".d.ts";

        var target = basepath + "/node_modules/" + module.name + "/decl/" + module.references[n] + ".d.ts";

        if (fs.existsSync(source)) {
            var readstream = fs.createReadStream(source);

            var writestream = fs.createWriteStream(target);

            readstream.pipe(writestream);
        }
    }
}
exports.copy_dependancies = copy_dependancies;

function build_module(module, basepath, callback) {
    api.reset();

    console.log('building ' + module.name);

    exports.copy_dependancies(module, basepath);

    var indexfile = basepath + "/node_modules/" + module.name + "/index.ts";

    console.log('   resolving units... ');

    api.resolve([indexfile], function (resolved) {
        if (!api.check(resolved)) {
            exports.show_errors(resolved);

            callback(false);

            return;
        }

        console.log('   compiling units...');

        api.compile(resolved, function (compiled) {
            if (!api.check(compiled)) {
                exports.show_errors(compiled);

                callback(false);

                return;
            }

            console.log('   writing...');

            exports.write_source(module, basepath, compiled);

            exports.write_declaration(module, basepath, compiled);

            console.log('   complete');

            callback(true);
        });
    });
}
exports.build_module = build_module;
function build(project, callback) {
    var modules = exports.sort(project.modules);

    async.concatSeries(modules, function (module, callback) {
        if (module.build == false) {
            console.log('excluded ' + module.name);

            callback(null, true);

            return;
        }

        exports.build_module(module, project.basepath, function (success) {
            callback(null, success);
        });
    }, function (err, results) {
        setTimeout(function () {
            callback();
        }, 200);
    });
}
exports.build = build;



module.exports = exports;