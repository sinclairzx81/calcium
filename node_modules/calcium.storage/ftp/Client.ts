/// <reference path="../decl/node.d.ts" />
/// <reference path="../decl/calcium.logging.d.ts" />

module calcium.storage.ftp 
{
    var node:any = 
    {
        net     : <net>require('net'),

        stream  : <stream>require('stream')
    }
    
    export class Credential
    {
        constructor(public user:string, public pass:string) { }
    }

    export class EndPoint
    {
        constructor(public host:string, public port:number) { }
    }
    
    export class Response 
    {
        public code    : number;

        public messages: string[];

        constructor()
        {
            this.code     = 0;

            this.messages = [];
        }
    }
    
    export class Client
    {
        private socket          : net.NodeSocket;

        private responses       : calcium.storage.ftp.Response[];
        
        private response_buffer : string[];
        
        private callbacks       : { (response:calcium.storage.ftp.Response) : void; }[];
        
        constructor(public endpoint   : calcium.storage.ftp.EndPoint,

                    public credential : calcium.storage.ftp.Credential,

                    public logger     : calcium.logging.ILogger) 
        {
            this.socket = new node.net.Socket();

            this.socket.setTimeout(0);
                
            this.socket.setEncoding('ascii');

            this.socket.on("readable", () =>  { this.accept(); });

            this.socket.on("end",      () =>  { this.socket.destroy(); });
            
            this.socket.on("error",    (err) => { this.logger.log(err) });            


            this.responses       = [];

            this.response_buffer = [];

            this.callbacks       = [];
        }
        

        public connect(callback: { ( response:calcium.storage.ftp.Response ) : void; } ) : void {
                        
            this.socket.connect(this.endpoint.port, this.endpoint.host, () =>{
               
               this.callbacks.push(callback);

            });
        }

        public login(callback: { ( response:calcium.storage.ftp.Response ) : void; } ) : void {
            
            this.command("USER " + this.credential.user, (response) => {
                   
                this.command("PASS " + this.credential.pass, callback);
            });
        }

        public disconnect(callback: { ( response:calcium.storage.ftp.Response ) : void; } ) : void {

            this.command("QUIT", (response) => {
            
                this.socket.destroy();

                callback(response);
            })
        }         

        public command(request:string, callback:{(response:calcium.storage.ftp.Response):void;}) : void
        {
            this.logger.log ("request : " + request);
            
            this.socket.write(request + '\r\n', 'ascii', () => { 
            
                this.callbacks.push(callback);
            
            });
        }

        public wait(callback:{(response:calcium.storage.ftp.Response):void;}) : void {
            
            this.callbacks.push(callback);

            if(this.responses.length > 0) 
            {
                var callback = this.callbacks.pop();

                callback( this.responses.shift() );
            }
        }
        
        public passive    (pasv_response:calcium.storage.ftp.Response, callback: { ( stream : stream.ReadableStream):void; } ) : void {
            
            if(pasv_response.code == 227)
            {
                var prefix  = new RegExp("^(.*)\\(", "g");

                var postfix = new RegExp("\\)", "g");

                if(pasv_response.messages.length > 0)
                {
                    var message = pasv_response.messages[0];

                    message = message.replace(prefix, '');

                    message = message.replace(postfix, '');

                    var split = message.split(',');

                    if(split.length == 6) 
                    {
                        var host = [split[0], split[1], split[2], split[3]].join('.');

                        var port = (parseInt(split[4]) * 256) + parseInt(split[5]);

                        var socket = new node.net.Socket();

                        this.logger.log('   passive socket connecting : ' + host + ':' + port.toString());

                        socket.connect(port, host, () =>  { });

                        socket.on("connect", () => {

                             this.logger.log('   passive socket connected  : ' + host + ':' + port.toString());
                             
                             callback(socket);  

                        });
                        
                        socket.on("error",    (err) => { this.logger.log(err) });                        

                        return;
                    }
                }
            }
            else
            {
                this.logger.log("cannot enter passive mode as passive mode response is not 227, got " + pasv_response.code.toString() );
            }
        }
        
        private accept () : void 
        {
            // read any data in the socket stream....

            var chunk; 
		
            while ( (chunk = this.socket.read() ) !== null )  
            { 
                this.response_buffer.push(chunk);
            }

            this.response_buffer.push(chunk);
			
            var lines = [];

            // load lines...
            
            var split = this.response_buffer.join('').split('\r\n');

            for(var n in split)
            {
                var line = split[n].trim();

                if(line.length > 0)
                {
                    lines.push(line);
                }
            }

            // if no lines. just return...

            if(lines.length == 0) return;

            // check if we have a complete response, if not, return..
            
            if(lines[lines.length - 1].indexOf('-') == 3)   
            {
                return;
            }
            
			// function to parse a server response line.
			var parse_line = (line:string) : { code:number; message:string; } => {
			
				return  {
					
                    code : parseInt( line.substr(0, 3) ),

					message : line.substr(4, line.length - 4)
				};
			}
			
            // create responses

            var responses = [];
			
            for(var n in lines)
            {
                var line = lines[n];

				this.logger.log('response: ' + line);
				
				var line_data = parse_line(line);
			
				if(n == 0)
				{
					var response = new calcium.storage.ftp.Response();
					
					response.code = line_data.code;
					
					response.messages.push(line_data.message);
					
					responses.push(response);
				}
				else
				{
					var last = responses[responses.length - 1];
					
					if(last.code == line_data.code)
					{
						last.messages.push(line_data.message);
					}
					else
					{
						var response = new calcium.storage.ftp.Response();
						
						response.code = line_data.code;
						
						response.messages.push(line_data.message);
						
						responses.push(response);					
					}
				}
			}	
			
			for(var n in responses)
			{
                this.responses.push( responses[n] )
			}

            // reset the buffer...

            this.response_buffer = [];
            
            // dispatch

            if(this.responses.length > 0) 
            {
                if(this.callbacks.length > 0) 
                {
                    var callback = this.callbacks.pop();

                    callback( this.responses.shift() );
                }
            }
        }
    }
}